party Maintainer;
party Contributor;
party Script;

party Admin;
party GitHoneyAddr;
party Sponsor;

party FTAddress;
party ScriptBadge;
party PayAddress;

type CardanoAddress {
    payment_credential: CardanoCredential,
    staking_credential: OptionAddressCardanoCredential,
}

type GithoneyContractRedeemers {
    AddRewards,
    Assign,
    Merge,
    Close,
    Claim,
}

type SettingsRedeemers {
    UpdateSettings,
    CloseSettings,
}

type SettingsDatum {
    githoney_address: CardanoAddress,
    bounty_creation_fee: Int,
    bounty_reward_fee: Int,
}

type OptionAddress {
    Some {
        address: CardanoAddress,
    },
    None,
}

type CardanoCredential {
    VerificationKey {
        VerificationKey: Bytes,
    },
    Script {
        Script: Bytes,
    },
}

type StakeCredWrapper {
    Inline {
        VerificationKey: CardanoCredential,
    },
    Pointer {
        slotNumber: Int,
        transactionIndex: Int,
        certificateIndex: Int,
    },
}

type OptionAddressCardanoCredential {
    Some {
        stakeCredetial: StakeCredWrapper,
    },
    None,
}

type GithoneyDatum {
    admin_payment_credential: CardanoCredential,
    maintainer_address: CardanoAddress,
    contributor_address: OptionAddress,
    bounty_reward_fee: Int,
    deadline: Int,
    merged: Bool,
    initial_value: Map<Bytes, Map<Bytes, Int>>,
}

type BadgesDatum {
    metadata: Map<Bytes, Bytes>,
    version: Int,
}

// // BADGES

// // DEPLOY BADGE

// tx deployBadge(
//     description: Bytes,
//     descriptionValue: Bytes,
//     ftBadgeAmount: Int,
//     ftBadgeName: Bytes,
//     logo: Bytes,
//     logoValue: Bytes,
//     mVersion: Int,
//     mintingPolicyId: Bytes,
//     name: Bytes,
//     nameValue: Bytes,
//     policyScript: Bytes,
//     policyScriptVersion: Int,
//     refNftAssetName: Bytes,
//     utxoRef: UtxoRef,
// ) {
//     collateral {
//         from: GitHoneyAddr,
//         min_amount: Ada(20000000),
//     }

//     input githoney_wallet {
//         ref: utxoRef,
//     }

//     mint {
//         amount: AnyAsset(mintingPolicyId, refNftAssetName, 1) + AnyAsset(mintingPolicyId, ftBadgeName, ftBadgeAmount),
//         redeemer: (),
//     }

//     output badge_utxo {
//         to: ScriptBadge,
//         amount: min_utxo(badge_utxo) + AnyAsset(mintingPolicyId, refNftAssetName, 1),
//         datum: BadgesDatum {
//             metadata: {
//                 name: nameValue,
//                 logo: logoValue,
//                 description: descriptionValue,
//             },
//             version: mVersion,
//         },
//     }

//     output ft_output {
//         to: FTAddress,
//         amount: AnyAsset(mintingPolicyId, ftBadgeName, ftBadgeAmount) + min_utxo(ft_output),
//     }

//     output change {
//         to: GitHoneyAddr,
//         amount: githoney_wallet - fees - min_utxo(ft_output) - min_utxo(badge_utxo),
//     }

//     cardano::plutus_witness {
//         version: policyScriptVersion,
//         script: policyScript,
//     }

//     metadata {
//         674: "Creating badges",
//     }
// }

// // UPDATE BADGE METADATA

// tx updateBadge(
//     badgesScript: Bytes,
//     badgesScriptVersion: Int,
//     description: Bytes,
//     descriptionValue: Bytes,
//     logo: Bytes,
//     logoValue: Bytes,
//     mVersion: Int,
//     name: Bytes,
//     nameValue: Bytes,
//     settingsRef: UtxoRef,
//     utxoRef: UtxoRef,
//     utxoToCollect: UtxoRef,
// ) {
//     collateral {
//         from: GitHoneyAddr,
//         min_amount: Ada(20000000),
//     }

//     input githoney_wallet {
//         ref: utxoRef,
//     }

//     reference settings_utxo {
//         ref: settingsRef,
//     }

//     input current {
//         ref: utxoToCollect,
//         redeemer: (),
//     }

//     output badge_utxo {
//         to: ScriptBadge,
//         amount: current,
//         datum: BadgesDatum {
//             metadata: {
//                 name: nameValue,
//                 logo: logoValue,
//                 description: descriptionValue,
//             },
//             version: mVersion,
//         },
//     }

//     output change {
//         to: GitHoneyAddr,
//         amount: githoney_wallet - fees,
//     }


//     signers {
//         GitHoneyAddr,
//     }

//     cardano::plutus_witness {
//         version: badgesScriptVersion,
//         script: badgesScript,
//     }

//     metadata {
//         674: "Creating badges",
//     }
// }

// // PAY BADGES TO

// tx payBadgesTo(
//     badgeName: Bytes,
//     badgePolicy: Bytes
// ) {
//     input badges {
//         from: FTAddress,
//         min_amount: AnyAsset(badgePolicy, badgeName, 1),
//     }

//     input gas {
//         from: FTAddress,
//         min_amount: fees + min_utxo(payment) + min_utxo(change),
//     }

//     output payment {
//         to: PayAddress,
//         amount: AnyAsset(badgePolicy, badgeName, 1) + min_utxo(payment),
//     }

//     output change {
//         to: FTAddress,
//         amount: gas + badges - fees - min_utxo(payment) - AnyAsset(badgePolicy, badgeName, 1),
//     }
// }

// // COLLECT UTXOS FROM BADGES

// tx collectUtxos(
//     badgesScript: Bytes,
//     badgesScriptVersion: Int,
//     settingsRef: UtxoRef,
//     utxoRef: UtxoRef,
//     utxoToCollect: UtxoRef,
// ) {
//     collateral {
//         from: GitHoneyAddr,
//         min_amount: Ada(5000000),
//     }

//     reference settings_utxo {
//         ref: settingsRef,
//     }

//     input current {
//         ref: utxoToCollect,
//         redeemer: (),
//     }

//     input githoney_wallet {
//         from: GitHoneyAddr,
//         min_amount: fees,
//     }

//     output change {
//         to: GitHoneyAddr,
//         amount: githoney_wallet + current - fees,
//     }

//     signers {
//         GitHoneyAddr,
//     }

//     cardano::plutus_witness {
//         version: badgesScriptVersion,
//         script: badgesScript,
//     }
// }

// SETTINGS
// DEPLOY SETTINGS

tx deploy(
    creation_fee: Int,
    reward_fee: Int,
    githoney_payment_credential: Bytes,
    githoney_staking_credential: Bytes,
    githoney_script: Bytes,
    script_version: Int,
    settings_minting_version: Int,
    settings_minting_policy: Bytes,
    settings_policy_id: Bytes,
    settings_token_name: Bytes,
    utxo_ref: UtxoRef,
) {

    locals {
        publish_cost: Ada(5000000),
    }

    input one_shot_utxo {
        from: GitHoneyAddr,
        ref: utxo_ref,
    }

    input* githoney_wallet {
        from: GitHoneyAddr,
        min_amount: publish_cost,
    }

    collateral {
        from: GitHoneyAddr,
        min_amount: Ada(5000000),
    }

    mint {
        amount: AnyAsset(settings_policy_id, settings_token_name, 1),
        redeemer: (),
    }

    cardano::publish settings_utxo {
        to: Script,
        amount: publish_cost + AnyAsset(settings_policy_id, settings_token_name, 1),
        datum: SettingsDatum {
            githoney_address: CardanoAddress {
                payment_credential: CardanoCredential::VerificationKey {
                    VerificationKey: githoney_payment_credential,
                },
                staking_credential: OptionAddressCardanoCredential::Some {
                    stakeCredetial: StakeCredWrapper::Inline {
                        VerificationKey: CardanoCredential::VerificationKey {
                            VerificationKey: githoney_staking_credential,
                        },
                    },
                },
            },
            bounty_creation_fee: creation_fee,
            bounty_reward_fee: reward_fee,
        },
        version: script_version,
        script: githoney_script,
    }

    output change {
        to: GitHoneyAddr,
        amount: one_shot_utxo + githoney_wallet - fees - publish_cost,
    }

    cardano::plutus_witness {
        version: settings_minting_version,
        script: settings_minting_policy,
    }
}

// // UPDATE SETTINGS

// tx update(
//     bountyCreationFee: Int,
//     bountyRewardFee: Int,
//     githoneyScript: Bytes,
//     scriptVersion: Int,
//     settingsRef: UtxoRef,
//     settingsValidatorScript: Bytes,
//     settingsValidatorVersion: Int,
// ) {
//     collateral {
//         from: GitHoneyAddr,
//         min_amount: Ada(20000000),
//     }

//     input current {
//         ref: settingsRef,
//         datum_is: SettingsDatum,
//         redeemer: SettingsRedeemers::UpdateSettings {},
//     }

//     input githoney_wallet {
//         from: GitHoneyAddr,
//         min_amount: min_utxo(change) + fees,
//     }

//     cardano::publish settings_utxo {
//         to: Script,
//         amount: current,
//         datum: SettingsDatum {
//             githoney_address: current.githoney_address,
//             bounty_creation_fee: bountyCreationFee,
//             bounty_reward_fee: bountyRewardFee,
//         },
//         version: scriptVersion,
//         script: githoneyScript,
//     }

//     output change {
//         to: GitHoneyAddr,
//         amount: githoney_wallet - fees,
//     }

//     signers {
//         GitHoneyAddr,
//     }

//     cardano::plutus_witness {
//         version: settingsValidatorVersion,
//         script: settingsValidatorScript,
//     }
// }

// // CLOSE SETTINGS

// tx close(
//     githoneyPaymentCredential: Bytes,
//     githoneyStakingCredential: Bytes,
//     remainingAda: Int,
//     settingsMintingPolicy: Bytes,
//     settingsMintingVersion: Int,
//     settingsPolicyId: Bytes,
//     settingsRef: UtxoRef,
//     settingsTokenName: Bytes,
//     settingsValidatorScript: Bytes,
//     settingsValidatorVersion: Int,
// ) {
//     collateral {
//         from: GitHoneyAddr,
//         min_amount: Ada(20000000),
//     }

//     input githoney_wallet {
//         from: GitHoneyAddr,
//         min_amount: min_utxo(change) + fees,
//     }

//     input current {
//         ref: settingsRef,
//         datum_is: SettingsDatum,
//         redeemer: SettingsRedeemers::CloseSettings {},
//     }

//     mint {
//         amount: AnyAsset(settingsPolicyId, settingsTokenName, -1),
//         redeemer: (),
//     }

//     output change {
//         to: GitHoneyAddr,
//         amount: githoney_wallet - fees + Ada(remainingAda),
//     }

//     signers {
//         GitHoneyAddr,
//     }

//     cardano::plutus_witness {
//         version: settingsValidatorVersion,
//         script: settingsValidatorScript,
//     }

//     cardano::plutus_witness {
//         version: settingsMintingVersion,
//         script: settingsMintingPolicy,
//     }
// }


// BOUNTIES
// CREATE BOUNTY

// tx createWithToken(
//     adminPaymentCredential: CardanoCredential,
//     // Since the settingsutxo datum cannot be accessed,
//     // they are passed as parameters.
//     bountyCreationFee: Int,
//     bountyId: Bytes,
//     bountyRewardFee: Int,
//     manteinerAddress: CardanoAddress,
//     minAda: Int,
//     //NOTE - Since you cannot iterate over lists, we use a fixed asset.
//     mintingPolicyId: Bytes,
//     rewardAmount: Int,
//     rewardAssetName: Bytes,
//     rewardPolicyId: Bytes,
//     settingsRef: UtxoRef,
//     since: Int,
//     timeLimit: Int,
//     until: Int,
// ) {
//     reference contract {
//         ref: settingsRef,
//     }

//     collateral {
//         from: Maintainer,
//         min_amount: Ada(5000000),
//     }

//     input maintainer_input {
//         from: Maintainer,
//         min_amount: min_utxo(bounty_utxo) + min_utxo(maintainer_output) + AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount) + Ada(bountyCreationFee) + fees,
//     }

//     mint {
//         amount: AnyAsset(mintingPolicyId, bountyId, 1),
//         redeemer: (),
//     }

//     output bounty_utxo {
//         to: Script,
//         amount: Ada(minAda) + AnyAsset(mintingPolicyId, bountyId, 1) + AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount),
//         datum: GithoneyDatum {
//             admin_payment_credential: adminPaymentCredential,
//             maintainer_address: manteinerAddress,
//             contributor_address: OptionAddress::None {},
//             bounty_reward_fee: bountyRewardFee,
//             deadline: timeLimit,
//             merged: false,
//             initial_value: {
//                 rewardPolicyId: {
//                     rewardAssetName: rewardAmount,
//                 },
//                 "": {
//                     "": minAda,
//                 },
//             },
//         },
//     }

//     output githoney_wallet{
//         to: GitHoneyAddr,
//         amount: Ada(bountyCreationFee),
//     }

//     output maintainer_output {
//         to: Maintainer,
//         amount: maintainer_input - Ada(bountyCreationFee) - fees - AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount) - Ada(minAda),
//     }

//     validity {
//         until_slot: until,
//         since_slot: since,
//     }
// }

tx createWithLovelace(
    admin_payment_key: Bytes,
    bounty_creation_fee: Int,
    bounty_id: Bytes,
    bounty_rewards_fee: Int,
    maintainer_payment_key: Bytes,
    maintainer_stake_key: Bytes,
    min_ada: Int,
    minting_policy_id: Bytes,
    reward_amount: Int,
    settings_ref: UtxoRef,
    since: Int,
    time_limit: Int,
    until: Int,
) {
    reference contract {
        ref: settings_ref,
    }

    collateral {
        from: Maintainer,
        min_amount: Ada(5000000),
    }

    input maintainer_input {
        from: Maintainer,
        min_amount: min_utxo(bounty_utxo) + min_utxo(maintainer_output) + Ada(bounty_creation_fee + reward_amount) + fees,
    }

    mint {
        amount: AnyAsset(minting_policy_id, bounty_id, 1),
        redeemer: (),
    }

    output bounty_utxo {
        to: Script,
        amount: Ada(min_ada + reward_amount) + AnyAsset(minting_policy_id, bounty_id, 1),
        datum: GithoneyDatum {
            admin_payment_credential: CardanoCredential::VerificationKey {
                VerificationKey: admin_payment_key,
            },
            maintainer_address: CardanoAddress {
                payment_credential: CardanoCredential::VerificationKey {
                    VerificationKey: maintainer_payment_key,
                },
                staking_credential: OptionAddressCardanoCredential::Some {
                    stakeCredetial: StakeCredWrapper::Inline {
                        VerificationKey: CardanoCredential::VerificationKey {
                            VerificationKey: maintainer_stake_key,
                        },
                    },
                },
            },
            contributor_address: OptionAddress::None {},
            bounty_reward_fee: bounty_rewards_fee,
            deadline: time_limit,
            merged: false,
            initial_value: {
                "": {
                    "": min_ada + reward_amount,
                },
            },
        },
    }

    output githoney_wallet{
        to: GitHoneyAddr,
        amount: Ada(bounty_creation_fee),
    }

    output maintainer_output {
        to: Maintainer,
        amount: maintainer_input - Ada(bounty_creation_fee + reward_amount + min_ada) - fees,
    }

    validity {
        until_slot: until,
        since_slot: since,
    }
}

// ADD REWARDS

tx add(
    bountyRef: UtxoRef,
    minAda: Int,
    rewardAmount: Int,
    rewardAssetName: Bytes,
    rewardPolicyId: Bytes,
    settingsRef: UtxoRef,
    since: Int,
    until: Int,
) {
    reference contract {
        ref: settingsRef,
    }

    collateral {
        from: Sponsor,
        min_amount: Ada(5000000),
    }

    input sponsor_input {
        from: Sponsor,
        min_amount: min_utxo(sponsor_output) + AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount) + fees,
    }

    input current {
        ref: bountyRef,
        datum_is: GithoneyDatum,
        redeemer: GithoneyContractRedeemers::AddRewards {},
    }

    output bounty_utxo {
        to: Script,
        amount: current + AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount),
        datum: GithoneyDatum {
            admin_payment_credential: current.admin_payment_credential,
            maintainer_address: current.maintainer_address,
            contributor_address: current.contributor_address,
            bounty_reward_fee: current.bounty_reward_fee,
            deadline: current.deadline,
            merged: current.merged,
            initial_value: current.initial_value,
        },
    }

    output sponsor_output {
        to: Sponsor,
        amount: sponsor_input - fees - AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount),
    }

    validity {
        until_slot: until,
        since_slot: since,
    }
}

// // ASSIGN CONTRIBUTOR

// tx assign(
//     bountyRef: UtxoRef,
//     contributorPaymentCredential: Bytes,
//     contributorStakeCredential: Bytes,
//     minAda: Int,
//     settingsRef: UtxoRef,
//     since: Int,
//     until: Int,
// ) {
//     reference contract {
//         ref: settingsRef,
//     }

//     collateral {
//         from: Contributor,
//         min_amount: Ada(5000000),
//     }

//     input contributor_input {
//         from: Contributor,
//         min_amount: min_utxo(contributor_output) + Ada(minAda) + fees,
//     }

//     input current {
//         ref: bountyRef,
//         datum_is: GithoneyDatum,
//         redeemer: GithoneyContractRedeemers::Assign {},
//     }

//     output bounty_utxo {
//         to: Script,
//         amount: current + Ada(minAda), // 2 * minAda
//         datum: GithoneyDatum {
//             admin_payment_credential: current.admin_payment_credential,
//             maintainer_address: current.maintainer_address,
//             contributor_address: OptionAddress::Some {
//                 address: CardanoAddress {
//                     payment_credential: CardanoCredential::VerificationKey {
//                         VerificationKey: contributorPaymentCredential,
//                     },
//                     staking_credential: OptionAddressCardanoCredential::Some {
//                         stakeCredetial: StakeCredWrapper::Inline {
//                             VerificationKey: CardanoCredential::VerificationKey {
//                                 VerificationKey: contributorStakeCredential,
//                             },
//                         },
//                     },
//                 },
//             },
//             bounty_reward_fee: current.bounty_reward_fee,
//             deadline: current.deadline,
//             merged: current.merged,
//             initial_value: current.initial_value,
//         },
//     }

//     output contributor_output {
//         to: Contributor,
//         amount: contributor_input - fees - Ada(minAda),
//     }

//     validity {
//         until_slot: until,
//         since_slot: since,
//     }
// }

// // CLOSE BOUNTY

// tx closeBeforeContributor(
//     bountyId: Bytes,
//     bountyRef: UtxoRef,
//     minAda: Int,
//     mintingPolicyId: Bytes,
//     rewardAmount: Int,
//     rewardAssetName: Bytes,
//     rewardPolicyId: Bytes,
//     settingsRef: UtxoRef,
//     since: Int,
//     timeLimit: Int,
//     until: Int,
// ) {
//     reference contract {
//         ref: settingsRef,
//     }

//     collateral {
//         from: Admin,
//         min_amount: Ada(5000000),
//     }

//     input admin_input {
//         from: Admin,
//         min_amount: min_utxo(admin_output) + min_utxo(maintainer_output) + fees,
//     }

//     input current {
//         ref: bountyRef,
//         datum_is: GithoneyDatum,
//         redeemer: GithoneyContractRedeemers::Close {},
//     }

//     mint {
//         amount: AnyAsset(mintingPolicyId, bountyId, -1),
//         redeemer: (),
//     }

//     output maintainer_output {
//         to: Maintainer,
//         amount: Ada(minAda) + AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount),
//     }

//     output admin_output {
//         to: Admin,
//         amount: admin_input - fees,
//     }

//     validity {
//         until_slot: until,
//         since_slot: since,
//     }

//     signers {
//         Admin,
//     }
// }

// tx closeBeforeContributorWithReward(
//     bountyId: Bytes,
//     bountyRef: UtxoRef,
//     minAda: Int,
//     mintingPolicyId: Bytes,
//     rewardAmount: Int,
//     rewardAssetName: Bytes,
//     rewardPolicyId: Bytes,
//     settingsRef: UtxoRef,
//     since: Int,
//     refundingsAmount: Int,
//     refundingsAssetName: Bytes,
//     refundingsPolicyId: Bytes,
//     timeLimit: Int,
//     until: Int,
// ) {
//     reference contract {
//         ref: settingsRef,
//     }

//     collateral {
//         from: Admin,
//         min_amount: Ada(5000000),
//     }

//     input admin_input {
//         from: Admin,
//         min_amount: min_utxo(admin_output) + min_utxo(maintainer_output) + min_utxo(sponsor_output) + fees,
//     }

//     input current {
//         ref: bountyRef,
//         datum_is: GithoneyDatum,
//         redeemer: GithoneyContractRedeemers::Close {},
//     }

//     mint {
//         amount: AnyAsset(mintingPolicyId, bountyId, -1),
//         redeemer: (),
//     }

//     output maintainer_output {
//         to: Maintainer,
//         amount: Ada(minAda) + AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount),
//     }

//     output admin_output {
//         to: Admin,
//         amount: admin_input - fees - min_utxo(sponsor_output),
//     }

//     output sponsor_output {
//         to: Sponsor,
//         amount: AnyAsset(refundingsPolicyId, refundingsAssetName, refundingsAmount) + min_utxo(sponsor_output),
//     }

//     validity {
//         until_slot: until,
//         since_slot: since,
//     }

//     signers {
//         Admin,
//     }
// }

// tx closeAfterContributor(
//     bountyId: Bytes,
//     bountyRef: UtxoRef,
//     minAda: Int,
//     mintingPolicyId: Bytes,
//     rewardAmount: Int,
//     rewardAssetName: Bytes,
//     rewardPolicyId: Bytes,
//     settingsRef: UtxoRef,
//     since: Int,
//     timeLimit: Int,
//     until: Int,

// ) {
//     reference contract {
//         ref: settingsRef,
//     }

//     collateral {
//         from: Admin,
//         min_amount: Ada(5000000),
//     }

//     input admin_input {
//         from: Admin,
//         min_amount: min_utxo(admin_output) + min_utxo(maintainer_output) + fees,
//     }

//     input current {
//         ref: bountyRef,
//         datum_is: GithoneyDatum,
//         redeemer: GithoneyContractRedeemers::Close {},
//     }

//     mint {
//         amount: AnyAsset(mintingPolicyId, bountyId, -1),
//         redeemer: (),
//     }

//     output maintainer_output {
//         to: Maintainer,
//         amount: Ada(minAda) + AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount),
//     }

//     output contributor_output {
//         to: Contributor,
//         amount: Ada(minAda),
//     }

//     output admin_output {
//         to: Admin,
//         amount: admin_input - fees,
//     }

//     validity {
//         until_slot: until,
//         since_slot: since,
//     }

//     signers {
//         Admin,
//     }
// }

// tx closeAfterContributorWithReward(
//     bountyId: Bytes,
//     bountyRef: UtxoRef,
//     minAda: Int,
//     mintingPolicyId: Bytes,
//     rewardAmount: Int,
//     rewardAssetName: Bytes,
//     rewardPolicyId: Bytes,
//     settingsRef: UtxoRef,
//     since: Int,
//     refundingsAmount: Int,
//     refundingsAssetName: Bytes,
//     refundingsPolicyId: Bytes,
//     timeLimit: Int,
//     until: Int,
// ) {
//     reference contract {
//         ref: settingsRef,
//     }

//     collateral {
//         from: Admin,
//         min_amount: Ada(5000000),
//     }

//     input admin_input {
//         from: Admin,
//         min_amount: min_utxo(admin_output) + min_utxo(maintainer_output) + min_utxo(sponsor_output) + fees,
//     }

//     input current {
//         ref: bountyRef,
//         datum_is: GithoneyDatum,
//         redeemer: GithoneyContractRedeemers::Close {},
//     }

//     mint {
//         amount: AnyAsset(mintingPolicyId, bountyId, -1),
//         redeemer: (),
//     }

//     output maintainer_output {
//         to: Maintainer,
//         amount: Ada(minAda) + AnyAsset(rewardPolicyId, rewardAssetName, rewardAmount),
//     }

//     output contributor_output {
//         to: Contributor,
//         amount: Ada(minAda),
//     }

//     output admin_output {
//         to: Admin,
//         amount: admin_input - fees - min_utxo(sponsor_output),
//     }

//     output sponsor_output {
//         to: Sponsor,
//         amount: AnyAsset(refundingsPolicyId, refundingsAssetName, refundingsAmount) + min_utxo(sponsor_output),
//     }

//     validity {
//         until_slot: until,
//         since_slot: since,
//     }

//     signers {
//         Admin,
//     }
// }

// // MERGE BOUNTY

// tx merge(
//     bountyRef: UtxoRef,
//     githoneyFee: Int,
//     minAda: Int,
//     rewardAssetName: Bytes,
//     rewardPolicyId: Bytes,
//     scriptFee: Int,
//     settingsRef: UtxoRef,
//     since: Int,
//     until: Int,
// ) {
//     reference contract {
//         ref: settingsRef,
//     }

//     collateral {
//         from: GitHoneyAddr,
//         min_amount: Ada(5000000),
//     }

//     input admin_input {
//         from: Admin,
//         min_amount: min_utxo(admin_output) + fees,
//     }

//     input current {
//         ref: bountyRef,
//         datum_is: GithoneyDatum,
//         redeemer: GithoneyContractRedeemers::Merge {},
//     }


//     output bounty_utxo {
//         to: Script,
//         amount: current - AnyAsset(rewardPolicyId, rewardAssetName, githoneyFee) - Ada(minAda),
//         datum: GithoneyDatum {
//             admin_payment_credential: current.admin_payment_credential,
//             maintainer_address: current.maintainer_address,
//             contributor_address: current.contributor_address,
//             bounty_reward_fee: current.bounty_reward_fee,
//             deadline: current.deadline,
//             merged: true,
//             initial_value: current.initial_value,
//         },
//     }

//     output githoney_output {
//         to: GitHoneyAddr,
//         amount: AnyAsset(rewardPolicyId, rewardAssetName, githoneyFee) + min_utxo(githoney_output),
//     }

//     output maintainer_output {
//         to: Maintainer,
//         amount: Ada(minAda),
//     }

//     output admin_output {
//         to: Admin,
//         // NOTE: admin pays the min ada to create the githoney output (1168010 lovelace)
//         amount: admin_input - fees - min_utxo(githoney_output),
//     }

//     validity {
//         until_slot: until,
//         since_slot: since,
//     }

//     signers {
//         Admin,
//     }
// }

// // CLAIM BOUNTY

// tx claim(
//     bountyId: Bytes,
//     bountyRef: UtxoRef,
//     minAda: Int,
//     mintingPolicyId: Bytes,
//     settingsRef: UtxoRef,
//     since: Int,
//     until: Int,
// ) {
//     reference contract {
//         ref: settingsRef,
//     }

//     collateral {
//         from: Contributor,
//         min_amount: Ada(5000000),
//     }

//     input contributor_input {
//         from: Contributor,
//         min_amount: min_utxo(contributor_output) + fees,
//     }

//     input current {
//         ref: bountyRef,
//         datum_is: GithoneyDatum,
//         redeemer: GithoneyContractRedeemers::Claim {},
//     }

//     mint {
//         amount: AnyAsset(mintingPolicyId, bountyId, -1),
//         redeemer: (),
//     }

//     output contributor_output {
//         to: Contributor,
//         amount: contributor_input + current - AnyAsset(mintingPolicyId, bountyId, 1) - fees,
//     }

//     validity {
//         until_slot: until,
//         since_slot: since,
//     }
// }
